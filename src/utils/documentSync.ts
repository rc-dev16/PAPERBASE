/**
 * Document Sync to Supabase Backend
 * 
 * Mirrors IndexedDB/localStorage documents to Supabase for durability.
 * IndexedDB is the source of truth - backend is backup only.
 * 
 * Non-blocking: failures are logged but don't stop the app.
 * 
 * üîê Authentication: Pass an authenticated Supabase client (from useSupabaseClient hook)
 * for RLS-protected operations. If not provided, uses default client (no RLS).
 */

import { supabase } from "@/lib/supabase";
import type { SupabaseClient } from "@supabase/supabase-js";

/**
 * Frontend Document interface (matches ProjectPage.tsx)
 */
export interface FrontendDocument {
  id: string;
  projectId?: string;
  fileHash?: string;
  title: string;
  fileName: string;
  fileType?: string;
  version?: number;
  deletedAt?: string; // ISO timestamp
  trashUntil?: string; // ISO timestamp
  addedDate?: string; // ISO timestamp
  [key: string]: any; // Allow other fields (authors, abstract, etc.)
}

/**
 * Backend document row (matches Supabase schema)
 */
interface BackendDocument {
  id: string;
  project_id: string;
  file_hash: string;
  title: string;
  file_name: string;
  file_type: string;
  version: number;
  deleted_at: string | null;
  trash_until: string | null;
  created_at?: string;
}

/**
 * Convert frontend document to backend format
 */
function toBackendDocument(doc: FrontendDocument): BackendDocument | null {
  // Validate required fields
  if (!doc.id || !doc.projectId || !doc.fileHash || !doc.title || !doc.fileName || !doc.fileType) {return null;
  }

  return {
    id: doc.id,
    project_id: doc.projectId,
    file_hash: doc.fileHash,
    title: doc.title,
    file_name: doc.fileName,
    file_type: doc.fileType,
    version: doc.version || 1,
    deleted_at: doc.deletedAt || null,
    trash_until: doc.trashUntil || null,
    // created_at is auto-generated by Supabase, but we can use addedDate if available
    created_at: doc.addedDate || undefined,
  };
}

/**
 * Sync a single document to Supabase (upsert)
 * Non-blocking: logs errors but doesn't throw
 * 
 * @param doc - Frontend document to sync
 * @param supabaseClient - Optional authenticated Supabase client. If provided, uses RLS.
 *                        If not provided, uses default client (no RLS protection).
 * @returns true if successful, false otherwise
 */
export async function syncDocumentToBackend(
  doc: FrontendDocument,
  supabaseClient?: SupabaseClient
): Promise<boolean> {
  try {
    const backendDoc = toBackendDocument(doc);
    if (!backendDoc) {
      return false;
    }

    // Use provided authenticated client, or fall back to default
    const client = supabaseClient || supabase;

    // Upsert: insert if new, update if exists
    // If authenticated client is used, RLS will enforce ownership
    const { error } = await client
      .from("documents")
      .upsert(backendDoc, {
        onConflict: "id",
      });

    if (error) {return false;
    }return true;
  } catch (error) {return false;
  }
}

/**
 * Sync multiple documents to Supabase (batch upsert)
 * Non-blocking: logs errors but doesn't throw
 * 
 * @param docs - Array of frontend documents to sync
 * @returns Number of successfully synced documents
 */
export async function syncDocumentsToBackend(docs: FrontendDocument[]): Promise<number> {
  try {
    const backendDocs = docs
      .map(toBackendDocument)
      .filter((doc): doc is BackendDocument => doc !== null);

    if (backendDocs.length === 0) {
      return 0;
    }

    // Batch upsert
    const { error } = await supabase
      .from("documents")
      .upsert(backendDocs, {
        onConflict: "id",
      });

    if (error) {return 0;
    }return backendDocs.length;
  } catch (error) {return 0;
  }
}

/**
 * Sync document trash state (deletedAt, trashUntil)
 * Used when moving to trash or restoring
 * 
 * @param documentId - Document ID
 * @param deletedAt - ISO timestamp or null
 * @param trashUntil - ISO timestamp or null
 * @returns true if successful, false otherwise
 */
export async function syncDocumentTrashState(
  documentId: string,
  deletedAt: string | null,
  trashUntil: string | null
): Promise<boolean> {
  try {
    const { error } = await supabase
      .from("documents")
      .update({
        deleted_at: deletedAt,
        trash_until: trashUntil,
      })
      .eq("id", documentId);

    if (error) {return false;
    }return true;
  } catch (error) {return false;
  }
}

/**
 * Sync multiple documents' trash state (batch update)
 * 
 * @param documentIds - Array of document IDs
 * @param deletedAt - ISO timestamp or null
 * @param trashUntil - ISO timestamp or null
 * @returns Number of successfully synced documents
 */
export async function syncDocumentsTrashState(
  documentIds: string[],
  deletedAt: string | null,
  trashUntil: string | null
): Promise<number> {
  try {
    if (documentIds.length === 0) {
      return 0;
    }

    const { error } = await supabase
      .from("documents")
      .update({
        deleted_at: deletedAt,
        trash_until: trashUntil,
      })
      .in("id", documentIds);

    if (error) {return 0;
    }return documentIds.length;
  } catch (error) {return 0;
  }
}

/**
 * Load documents from Supabase (for recovery/sync)
 * Not used in normal flow - IndexedDB is source of truth
 * 
 * @param projectId - Project ID to load documents for
 * @returns Array of frontend documents or empty array on error
 */
export async function loadDocumentsFromBackend(projectId: string): Promise<FrontendDocument[]> {
  try {
    const { data, error } = await supabase
      .from("documents")
      .select("*")
      .eq("project_id", projectId)
      .order("created_at", { ascending: false });

    if (error) {return [];
    }

    if (!data) {
      return [];
    }

    // Convert backend format to frontend format
    const frontendDocs: FrontendDocument[] = data.map((row) => ({
      id: row.id,
      projectId: row.project_id,
      fileHash: row.file_hash,
      title: row.title,
      fileName: row.file_name,
      fileType: row.file_type,
      version: row.version,
      deletedAt: row.deleted_at || undefined,
      trashUntil: row.trash_until || undefined,
      addedDate: row.created_at || undefined,
    }));return frontendDocs;
  } catch (error) {return [];
  }
}

